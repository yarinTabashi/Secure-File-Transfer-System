#pragma once
#include "protocol_handle.h"
#include "files_handler.h"
#include <string>
#include <boost/asio.hpp>
#include "cksum.h"
#include "encryption.h"

#define DEFAULT_ADDRESS "127.0.0.1"
#define DEFAULT_PORT (1256)
#define attemptsNo (3)

class ClientSession
{
public:
	/*
	*@brief It establishes a connection to the server using the server configuration fetched from the 'transfer' file,
	* and performs register or login.
	*/
	ClientSession(const std::string& transfer_filename);
	bool login();
	bool reg();
	bool send_public_key();
	/**
	 * @brief Sends a file to the server.
	 *
	 * This function sends the specified file to the server after performing necessary validations.
	 *
	 * @param file_path The path to the file to be sent.
	 *
	 * @throws std::runtime_error if the file doesn't exist or if the file name is too long.
	 */
	void send_file(std::filesystem::path file_path);

private:
	boost::asio::io_context io_context;
	tcp::socket socket;
	bool is_initialized = false;
	std::string name = "";
	u_char uuid[CLIENT_ID_LENGTH] = { 0 };
	Encryption encryption_obj; // Object handling and saving the keys.
	bool read_symetric_key(ResponseId res_id, unsigned int payload_size);

	/**
	* @brief Check whether the client is already registered, and if so to set the properties.
	*/ 
	bool initialize_user();

	// Helper functions for handling file sending
	/**
	* @brief Manages retries for sending a file to the server and handles CRC validation.
	* @return Whether the file sending succeeded (valid CRC received).
	*/
	bool retries_handle(std::filesystem::path file_path, unsigned long local_cksum);
	/**
	* @brief Notifies the server about the status of CRC validation for a file.
	* Then, it recieves the server's response in case of success\abort.
	*/
	void notifyServerCRCStatus(std::filesystem::path file, RequestId req_id);
	/**
	* @brief Sends a file to the server and retrieves the calculated checksum.
	* @return The computed checksum generated by the server.
	*/
	unsigned long send_once_process(std::filesystem::path file, const std::string& encrypted_file);
	/**
	*@brief Sends encrypted file content to the server in chunks.
	*/
	void send_file_in_chunks(std::string encrypted_content, SendFilePayload sending_req);
};

class Exception : public std::runtime_error
{
public:
	explicit Exception(const std::string& message) : std::runtime_error(message) {}
};